use bluer::{AdapterEvent, Session};
use futures::StreamExt;
use std::collections::HashSet;
use std::collections::HashMap;
use btsensor::{bthome, Reading};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Connect to BlueZ over D-Bus
    let session = Session::new().await?;
    let adapter = session.default_adapter().await?;
    adapter.set_powered(true).await?;

    println!("Discovering BLE devicesâ€¦");

    // Stream of discovery events
    let mut events = adapter.discover_devices().await?;

    // Optional: track known addresses so we don't print duplicates constantly
    let mut seen = HashSet::new();

    while let Some(evt) = events.next().await {
        match evt {
            AdapterEvent::DeviceAdded(addr) => {
                if seen.insert(addr) {
                    let device = adapter.device(addr)?;
                    let name = device.name().await?;
                    let rssi = device.rssi().await?;
                    println!("\nðŸ“¡ Found device: {addr:?}, name={name:?}, rssi={rssi:?}");

                    // Manufacturer data (Company ID + bytes)
                    if let Some(manuf_data) = device.manufacturer_data().await? {
                        for (company_id, data) in manuf_data {
                            println!("  ðŸ­ Manufacturer ID: {company_id}, data: {:02X?}", data);
                        }
                    }

                    // Service data (UUID + bytes)
                    if let Some(service_data) = device.service_data().await? {
                        //for (uuid, data) in service_data {
                        //    println!("  ðŸ§© Service UUID: {uuid}, data: {:02X?}", data);
                        //}
                        //for (uuid, data) in service_data {
                            //let decoded = Reading::decode(data).unwrap();
                            if let Some(reading) = Reading::decode(&service_data) {
                                println!("  {reading}");
                            } else {
                                println!("  (Failed to decode.)");
                            }
                            //println!("{}", decoded);
                        //}
                    }

                    // Service UUIDs list
                    if let Some(uuids) = device.uuids().await? {
                        println!("  ðŸ”¹ Advertised services: {uuids:?}");
                    }
                }
            }

            // If you want to track when a device vanishes:
            AdapterEvent::DeviceRemoved(addr) => {
                seen.remove(&addr);
                println!("âŒ Device removed: {addr:?}");
            }

            _ => {}
        }
    }

    Ok(())
}